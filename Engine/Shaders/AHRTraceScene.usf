// @RyanTorant
#include "Common.usf"
#include "DeferredShadingCommon.usf"
#include "AHRCommon.usf"

// RSM textures
// Hardcoded to a maximum of five for now
Texture2D ShadowAlbedo0;
Texture2D ShadowAlbedo1;
Texture2D ShadowAlbedo2;
Texture2D ShadowAlbedo3;
Texture2D ShadowAlbedo4;

Texture2D ShadowNormals0;
Texture2D ShadowNormals1;
Texture2D ShadowNormals2;
Texture2D ShadowNormals3;
Texture2D ShadowNormals4;

Texture2D ShadowZ0;
Texture2D ShadowZ1;
Texture2D ShadowZ2;
Texture2D ShadowZ3;
Texture2D ShadowZ4;

// The projection matrices are inside a constant buffer

float3 to_vlocal(float3 worldPos)
{
	// Let's get mad!
	// (x - a)/b		   : add + div
	// (x - a)*c , c = 1/b : add + mul
	// x*c + d, d = -a/b   : mad
	return worldPos*AHRTraceCB.InvSceneBounds + AHRTraceCB.WorldToVoxelOffset;

	// HARDCODED DEBUG!
	//const float invSceneBounds = 1.0f/2150.0f;
	//const float3 worldTovoxelOffset = -float3(-265.486847f,0.0f,0.0f)/2150.0f;

	//return worldPos*invSceneBounds + worldTovoxelOffset;
}

ByteAddressBuffer SceneVolume;
SamplerState samLinear;
SamplerComparisonState cmpSampler;

static const uint seedkernel[16] = 
{ 
	906459532, 72893876, 492795701, 532344103,
	326635764, 417976112, 293516711, 189627760,
	705480491, 423810863, 187018483, 239779822,
	1740361530, 226519499, 1570237062, 389231761
};

float4 PS(float2 InUV : TEXCOORD0,float3 ScreenVector : TEXCOORD1) : SV_TARGET0
{
	float SceneDepth = CalcSceneDepth(InUV);
	float3 wPos = ScreenVector * SceneDepth + View.ViewOrigin.xyz;


	// Exit early if we are out of bounds
	//if(magnitudeSquared(to_vlocal(wPos)) > 3) 
		//return float4(0,0,0,1);

	FScreenSpaceData ScreenSpaceData = GetScreenSpaceData(InUV);

	float3 normal = ScreenSpaceData.GBuffer.WorldNormal;
	float3 reflectVec = normalize(-reflect(-normalize(ScreenVector), normal));

	uint2 DTid = InUV * AHRTraceCB.ScreenRes;

	uint2 quadUV = (DTid.xy) % 4;
	uint seed = seedkernel[quadUV.x + quadUV.y*4];
	NumberGenerator rng;
	rng.SetSeed( seed );

	uint bvox = -1;
	uint prevbidx = -1;
	float3 rkernel = {-0.721016, 0.692918, -1.0};

	// Construct normal space
	float3 tangent = normalize(rkernel - normal * dot(rkernel, normal));
	float3 bitangent = cross(normal, tangent);



//#define _GLOSSY



	// Construct reflection space
#ifdef _GLOSSY
	float3 tangentR = normalize(rkernel - reflectVec * dot(rkernel, reflectVec));
	float3 bitangentR = cross(reflectVec, tangentR);
#endif

	float3 diffuse = 0;
	float3 glossy = 0;

#ifdef _GLOSSY
	for (uint r = 0; r < AHRTraceCB.GlossyRayCount; r++)
	{
		float3 dir = 0;

		dir.x = rng.GetRandomFloat(0, 1)*2-1;
		dir.y = rng.GetRandomFloat(0, 1)*2-1;
		dir.z = 1;

		// Apply dispersion based on the material roughness
		// Disabled for now (8/11/2014)
		dir.xy *= 0.05; // totally fake. something around a kinda polished stone? 0 is a perfect mirror

		// Convert to vector space
		dir = dir.x * tangentR + (dir.y * bitangentR + (dir.z * reflectVec));

		float angleCos = saturate(dot(dir,normal));
		// tan(acos(x)) = sqrt(1 - x*x)/x;
		float dispAngleMult = sqrt(1 - angleCos*angleCos)/(angleCos + 0.01) + 1;//tan(clamp(dispAngle,0,MAX_ANGLE)) + 1;

		// Optimize this later. Div is stupid
		float3 step = dir*AHRTraceCB.invVoxel/AHRTraceCB.InvSceneBounds;
		float3 spos = wPos + step*AHRTraceCB.InitialDispMult*dispAngleMult;

		step *= AHRTraceCB.SamplesDispMultiplier;

		// Rework this when enabling transparency
		// Instead of breaking on hit, accumulate alpha and break when it's big enough
		for (uint i = 0; i < AHRTraceCB.GlossySamplesCount; i++)
		{
			if(magnitudeSquared(to_vlocal(spos)) > 3) 
			{
				// Here we could intersect the ray with the sky sphere and take that color...
				//glossy += AHRTraceCB.LostRayColor;//float3(0.4f, 0.675f, 0.99f);
				//acc++;
				break;
			}

			uint3 vpos = floor((to_vlocal(spos)*0.5 + 0.5)*AHRTraceCB.SliceSize);
			uint vidx = vpos.y + vpos.x*AHRTraceCB.SliceSize + vpos.z*AHRTraceCB.SliceSize*AHRTraceCB.SliceSize;

#define ONE_OVER_32 0.03125f
			uint bidx = floor(float(vidx) * ONE_OVER_32);
			uint offset = vidx - 32 * bidx;

			if (bidx != prevbidx)
			{
				bvox = SceneVolume.Load(bidx*4);
				prevbidx = bidx;
			}
			bool hit = bvox & (1 << offset);

			if (hit)
			{
				// Light sampling "loop"
				{
					//float4 lpos = fmul(spos + AHRShadowMatrices.Offset0,AHRShadowMatrices.Matrix0);
					float4 lpos = fmul(spos,AHRShadowMatrices.Matrix0);

					//re-homogenize position after interpolation
					lpos.xyz /= lpos.w;

					
					//transform clip space coords to texture space coords (-1:1 to 0:1)
					lpos.x = lpos.x*0.5 + 0.5;
					lpos.y = -lpos.y*0.5 + 0.5;

					float4 sAlbedo = ShadowAlbedo0.SampleLevel(samLinear,lpos.xy,0);
					float4 sNormal = ShadowNormals0.SampleLevel(samLinear,lpos.xy,0);
					//float biasAngleMult = sqrt(1 - albedo.w*albedo.w)/(albedo.w + 0.01) + 1; // the w component stores the dot of the sun dir and normal
					float biasAngleMult = 1;
					sAlbedo.w = 1;
					float shadowFactor = ShadowZ0.SampleCmpLevelZero(cmpSampler, lpos.xy, lpos.z);
				
					glossy += shadowFactor*sAlbedo.rgb*sAlbedo.w;
				}

				break;
			}
			spos += step;
		}
	}
	glossy /= AHRTraceCB.GlossyRayCount;
#endif

	float ao = 0;
	for (uint r = 0; r < AHRTraceCB.DiffuseRayCount; r++)
	{
		float3 dir = 0;

		dir.x = rng.GetRandomFloat(0, 1)*2-1;
		dir.y = rng.GetRandomFloat(0, 1)*2-1;
		dir.z = 1;

		// Apply dispersion
		// Extremely fake. While a proper BRDF integrates over the entire hemisphere, restricting it to a narrower cone does the trick, and looks better
		// Adds some "normal influence". Totally fake, but looks better
		dir.xy *= 0.85; 

		// Convert to vector space
		dir = normalize(dir.x * tangent + (dir.y * bitangent + (dir.z * normal)));

		float angleCos = saturate(dot(dir,normal));
		float dispAngleMult = sqrt(1 - angleCos*angleCos)/(angleCos + 0.01) + 1;//tan(clamp(dispAngle,0,MAX_ANGLE)) + 1;

		// Optimize this later. Div is stupid
		float3 step = dir*AHRTraceCB.invVoxel/AHRTraceCB.InvSceneBounds;
		float3 spos = wPos + step*AHRTraceCB.InitialDispMult*dispAngleMult;
		//float3 step = dir*(2150.0f/512.0f);
		//float3 spos = wPos + step*1.9f*dispAngleMult;

		step *= AHRTraceCB.SamplesDispMultiplier;

		for (uint i = 0; i < AHRTraceCB.DiffuseSamplesCount; i++)
		{
			if(magnitudeSquared(to_vlocal(spos)) > 3) 
			{
				// Here we could intersect the ray with the sky sphere and take that color...
				//diffuse += AHRTraceCB.LostRayColor;//float3(0.4f, 0.675f, 0.99f);
				//acc++;
				break;
			}

			uint3 vpos = floor((to_vlocal(spos)*0.5 + 0.5)*AHRTraceCB.SliceSize);
			uint vidx = vpos.y + vpos.x*AHRTraceCB.SliceSize + vpos.z*AHRTraceCB.SliceSize*AHRTraceCB.SliceSize;

#define ONE_OVER_32 0.03125f
			uint bidx = floor(float(vidx) * ONE_OVER_32);
			uint offset = vidx - 32 * bidx;

			if (bidx != prevbidx)
			{
				bvox = SceneVolume.Load(bidx*4);
				prevbidx = bidx;
			}
			bool hit = bvox & (1 << offset);

			if (hit)
			{
				/* This will depend on how does RSM work on UE4
				float4 lpos = fmul(spos,LightVP);

				//re-homogenize position after interpolation
				lpos.xyz /= lpos.w;

				//transform clip space coords to texture space coords (-1:1 to 0:1)
				lpos.x = lpos.x*0.5 + 0.5;
				lpos.y = -lpos.y*0.5 + 0.5;

				float4 albedo = shadowAlbedo.SampleLevel(samLinear,lpos.xy,0);
				float biasAngleMult = sqrt(1 - albedo.w*albedo.w)/(albedo.w + 0.01) + 1; // the w component stores the dot of the sun dir and normal
				float shadowFactor = shadowZ.SampleCmpLevelZero(cmpSampler, lpos.xy, lpos.z-ShadowBias*biasAngleMult*0.01f);
				*/

				// Light sampling "loop"
				{
					//float4 lpos = fmul(spos + AHRShadowMatrices.Offset0,AHRShadowMatrices.Matrix0);
					float4 lpos = fmul(spos,AHRShadowMatrices.Matrix0);

					//re-homogenize position after interpolation
					lpos.xyz /= lpos.w;

					
					//transform clip space coords to texture space coords (-1:1 to 0:1)
					lpos.x = lpos.x*0.5 + 0.5;
					lpos.y = -lpos.y*0.5 + 0.5;

					float4 sAlbedo = ShadowAlbedo0.SampleLevel(samLinear,lpos.xy,0);
					float4 sNormal = ShadowNormals0.SampleLevel(samLinear,lpos.xy,0);
					//float biasAngleMult = sqrt(1 - albedo.w*albedo.w)/(albedo.w + 0.01) + 1; // the w component stores the dot of the sun dir and normal
					float biasAngleMult = 1;
					sAlbedo.w = 1;
					float shadowFactor = ShadowZ0.SampleCmpLevelZero(cmpSampler, lpos.xy, lpos.z);
					
					float rdist = magnitudeSquared(to_vlocal(spos)) / 3;
					rdist = (exp(-7*rdist*rdist) + 0.3)/1.3;

					diffuse += shadowFactor*sAlbedo.rgb*sAlbedo.w*rdist;
				}
				float rdist = magnitudeSquared(to_vlocal(spos)) / 3;
				ao += (exp(-7*rdist*rdist) + 0.3)/1.3;//(i <= 8);
				
				//acc += 1;

				break;
			}
			spos += step;
		}
	}
	//acc = AHRTraceCB.DiffuseRayCount;

	ao /= AHRTraceCB.DiffuseRayCount;
	ao = 1.0f - saturate(ao);

	diffuse /= AHRTraceCB.DiffuseRayCount;

	float3 fakeSky = lerp(float3(0.034,0.1,0.1),AHRTraceCB.LostRayColor,(dot(normal,float3(0,1,0)))*0.5+0.5 );
	fakeSky*= ScreenSpaceData.GBuffer.DiffuseColor;

#ifdef _GLOSSY
	// Should be based on the material roughness
	float4 traced = float4(lerp(glossy,diffuse,0.85) + fakeSky*ao*0.1,ao);
#else
	float4 traced = float4(diffuse + fakeSky*ao*0.1,ao);
#endif



	//traced = ao;
	/*
	if(InUV.x < 0.3)
		traced = ShadowAlbedo0.SampleLevel(samLinear,InUV,0);
	else if(InUV.x >= 0.3 && InUV.x < 0.6)
		traced = ShadowNormals0.SampleLevel(samLinear,InUV,0);
	else if(InUV.x >= 0.6)
		traced = ShadowZ0.SampleLevel(samLinear,InUV,0);*/

	//DEBUG!
	//uint vidxD = InUV.x*1000 + InUV.y*1000*1000;
	//traced = SceneVolume.Load((vidxD + 1000000)*4);

	/*uint3 vposD = floor((to_vlocal(wPos)*0.5 + 0.5)*AHRTraceCB.SliceSize);
	uint vidxD = vposD.y + vposD.x*AHRTraceCB.SliceSize + vposD.z*AHRTraceCB.SliceSize*AHRTraceCB.SliceSize;
	uint bidxD = floor(float(vidxD) * ONE_OVER_32);
	uint offsetD = vidxD - 32 * bidxD;
	uint bvoxD = SceneVolume.Load(bidxD*4);
	traced = bvoxD & (1 << offsetD);*/

	
//#define _SHOW_VOXELS
#ifdef _SHOW_VOXELS
	traced = 0;
	float3 dir = ScreenVector;
	float3 step = dir*(2150.0f/512.0f)*0.15f;
	float3 spos = View.ViewOrigin.xyz;
	uint prevbidx2 = -1;
	uint bvox2 = 0;

	for(int i = 0; i < 1000; i++)
	{
		float3 local = to_vlocal(spos);
		if( local.x > 1 || local.x < -1 ||
			local.y > 1 || local.y < -1 ||
			local.z > 1 || local.z < -1) break;

		uint3 vpos = floor((local*0.5 + 0.5)*512);
		uint vidx = vpos.y + vpos.x*512 + vpos.z*512*512;
		uint bidx = floor(float(vidx) * ONE_OVER_32);
		uint offset = vidx - 32 * bidx;
		
		if (bidx != prevbidx2)
		{
			bvox2 = SceneVolume.Load(bidx*4);
			prevbidx2 = bidx;
		}

		if(bvox2 & (1 << offset))
		{
			float3 vnormal = normalize(floor((to_vlocal(spos)*0.5 + 0.5)*512 + 0.5)  - (to_vlocal(spos)*0.5 + 0.5)*512);
			traced = vnormal.xyzz*0.5+0.5;

			break;
		}

		spos += step;
	}

#endif





/*
	float4 lpos = fmul(wPos,AHRShadowMatrices.Matrix0);
	
	//re-homogenize position after interpolation
	lpos.xyz /= lpos.w;

	//transform clip space coords to texture space coords (-1:1 to 0:1)
	lpos.x = lpos.x*0.5 + 0.5;
	lpos.y = -lpos.y*0.5 + 0.5;

	// clamp coordinates
	lpos.xy = saturate(lpos.xy);

	//float4 sNormal = ShadowNormals0.SampleLevel(samLinear,lpos.xy,0);
	traced = ShadowZ0.SampleCmpLevelZero(cmpSampler, lpos.xy, lpos.z);
	*/
	




	return traced;
}