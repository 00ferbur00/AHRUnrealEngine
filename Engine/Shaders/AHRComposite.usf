// @RyanTorant
#include "Common.usf"
#include "DeferredShadingCommon.usf"
#include "AHRCommon.usf"

void VS(
	in float2 InPosition : ATTRIBUTE0,
	in float2 InUV       : ATTRIBUTE1,
	out float2 OutTexCoord : TEXCOORD0,
	out float3 OutScreenVector : TEXCOORD1,
	out float4 OutPosition : SV_POSITION
	)
{	
	DrawRectangle(float4(InPosition.xy, 0, 1), InUV, OutPosition, OutTexCoord);
	OutScreenVector = mul(float4(OutPosition.xy, 1, 0), View.ScreenToTranslatedWorld).xyz;
}


Texture2D<float4> ObjNormal;
SamplerState samLinear;

Texture2D<float4> Trace0;
Texture2D<float4> Trace1;
Texture2D<float4> Trace2;
Texture2D<float4> Trace3;
Texture2D<float4> Trace4;
Texture2D<float4> Trace5;

float4 PS(float2 InUV : TEXCOORD0,float3 ScreenVector : TEXCOORD1) : SV_TARGET0
{
#if 0
	/*float SceneDepth = CalcSceneDepth(InUV);
	float3 WorldPosition = ScreenVector * SceneDepth + View.ViewOrigin.xyz;*/

	/*float3 fcolor = tGI.SampleLevel(samLinear,InUV,0);

	FScreenSpaceData ScreenSpaceData = GetScreenSpaceData(InUV);

	fcolor = fcolor*AHRCompositeCB.GIMultiplier*ScreenSpaceData.GBuffer.DiffuseColor;//pow(fcolor,AHRCompositeCB.GIMultiplier); 
	
	return float4(fcolor,1);*/


	FScreenSpaceData ScreenSpaceData = GetScreenSpaceData(InUV);

	uint2 res;
	tGI.GetDimensions(res.x,res.y);
	float4x4 sph = Decode4SPH(tGI[InUV*res]);

	float3 lnormal = normalize(ObjNormal.SampleLevel(samLinear,InUV,0))*2-1;
	float3 tangent = normalize(rkernel - lnormal * dot(rkernel, lnormal));
	float3 bitangent = cross(lnormal, tangent);

	float3 v0,v1,v2,v3;
	v0 = normalize(rayKernel[0].x * bitangent + (rayKernel[0].z * tangent + (rayKernel[0].y * lnormal)));
	v1 = normalize(rayKernel[1].x * bitangent + (rayKernel[1].z * tangent + (rayKernel[1].y * lnormal)));
	v2 = normalize(rayKernel[2].x * bitangent + (rayKernel[2].z * tangent + (rayKernel[2].y * lnormal)));
	v3 = normalize(rayKernel[3].x * bitangent + (rayKernel[3].z * tangent + (rayKernel[3].y * lnormal)));

	//float3 ivec = normalize(-reflect(-normalize(ScreenVector), ScreenSpaceData.GBuffer.WorldNormal));
	float3 ivec = ScreenSpaceData.GBuffer.WorldNormal;
	float4 coeffs = float4(pow(saturate(dot(ivec,v0)),1.6),
						   pow(saturate(dot(ivec,v1)),1.6),
						   pow(saturate(dot(ivec,v2)),1.6),
						   pow(saturate(dot(ivec,v3)),1.6) );

	float4 interp = sph[0] * coeffs.x +
					sph[1] * coeffs.y +
					sph[2] * coeffs.z +
					sph[3] * coeffs.w;
	//interp /= coeffs.x + coeffs.y + coeffs.z + coeffs.w;
	interp *= 0.25f;

	float3 fcolor = sph[0];//(sph[0]+sph[1]+sph[2]+sph[3]).rgb*0.25f;
	
	//float3 fcolor = interp*AHRCompositeCB.GIMultiplier*max(float3(0.085f,0.085f,0.085f),ScreenSpaceData.GBuffer.DiffuseColor);// + interp.w*0.1*max(float3(0.085f,0.085f,0.085f),ScreenSpaceData.GBuffer.DiffuseColor);
	
#endif
	FScreenSpaceData ScreenSpaceData = GetScreenSpaceData(InUV);


	float4 fcolor = Trace0.SampleLevel(samLinear,InUV,0) +
					Trace1.SampleLevel(samLinear,InUV,0) +
					Trace2.SampleLevel(samLinear,InUV,0) +
					Trace3.SampleLevel(samLinear,InUV,0) +
					Trace4.SampleLevel(samLinear,InUV,0);/* +
					Trace5.SampleLevel(samLinear,InUV,0) ;
	fcolor /= 6.0f;*/
	fcolor *= 0.2f;

	/*
	// After interpolation, add specular
	float3 H = normalize( dir + ScreenVector );
	color.rgb +=  pow(saturate(dot(normal,H)),5)
	*/
	



	float3 fakeSky = lerp(float3(0.034,0.1,0.1),float3(0.6f, 0.875f, 0.999f),ScreenSpaceData.GBuffer.WorldNormal.z*0.5+0.5 );
	fakeSky *= fakeSky;
	fakeSky = lerp(fakeSky,1,0.3);

	//fcolor.rgb *= AHRCompositeCB.GIMultiplier*ScreenSpaceData.GBuffer.DiffuseColor;
	//fcolor.rgb += fcolor.w*ScreenSpaceData.GBuffer.DiffuseColor*0.1f*fakeSky;

	return max(float4(fcolor.rgb,1),0); // prevent the shader from outputting negative lighting
}