// Copyright 1998-2014 Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LightAccumulator.usf: FLightAccumulator "class" and it's methods, useful for screen space subsurface scattering
=============================================================================*/

#ifndef __LIGHTACCUMULATOR_COMMON__
#define __LIGHTACCUMULATOR_COMMON__

// set by c++, not set for LPV
// 0 / 1
#ifndef VISUALIZE_LIGHT_CULLING
	#define VISUALIZE_LIGHT_CULLING 0
#endif

// for ScreenSpaceSubsurfaceScattering
// 0 : fastest (speculars leak in SSSSS)
// 1 : luminance specular works well (needs 64bit SceneColor, stores luminance of specular in alpha, can be optimized further in LightAccumulator_Add() ) 
// 2 : colored specular works well (best, requires another RT for light accumulation)
#define SUBSURFACE_CHANNEL_MODE 1

struct FLightAccumulator
{
	float3 TotalSum;

	// only actually used SUBSURFACE_CHANNEL_MODE != 0
	// assumed to be compiled out otherwise (not compiled out with #if so we can use if() instead of #if for better readability and compiler error checking)
	// input for ScreenSpaceSubsurfaceScattering
	float3 NonSpecularSum;

	// only used for development (not compiled out with #if so we can use if() instead of #if for better readability and compiler error checking)
	// assumed to be compiled out otherwise
	float EstimatedCost;
};

//
// accumulate light, can be called multiple times
void LightAccumulator_Add(inout FLightAccumulator In, float3 NonSpecularContribution, float3 SpecularContribution, float3 CommonMultiplier)
{
	if (SUBSURFACE_CHANNEL_MODE == 0)
	{
		// 3 add, 3 mad
		In.TotalSum += (NonSpecularContribution + SpecularContribution) * CommonMultiplier;
	}
	else
	{
		// 3 add, 3 mad
		In.TotalSum += (NonSpecularContribution + SpecularContribution) * CommonMultiplier;
		// 3 mad
		In.NonSpecularSum += NonSpecularContribution * CommonMultiplier;
	}
}

//
// compute final value to store in the MRT0
float4 LightAccumulator_GetResult(FLightAccumulator In)
{
	float4 Ret;

	if (VISUALIZE_LIGHT_CULLING == 1)
	{
		// similar to VISUALIZE_LIGHT_CULLING in tile based deferred lighting
		Ret = 0.1f * float4(1.0f, 0.25f, 0.075f, 0) * In.EstimatedCost;
	}
	else
	{
		Ret = float4(In.TotalSum, 0);

		if (SUBSURFACE_CHANNEL_MODE != 0)
		{
			// RGB accumulated RGB HDR color, A: specular luminance for screenspace subsurface scattering
			// 3 add,  1 mul, 2 mad, can be optimized to use 2 less temporary during accumulation and remove the 3 add
			Ret.a = Luminance(In.TotalSum - In.NonSpecularSum);
			// todo, need second MRT for SUBSURFACE_CHANNEL_MODE==2
		}
	}

	return Ret;
}

#endif // __LIGHTACCUMULATOR_COMMON__