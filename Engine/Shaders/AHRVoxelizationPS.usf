// @RyanTorant
#include "AHRCommon.usf"
#include "AHRVoxelizationCommon.usf"

RWByteAddressBuffer SceneVolume : register (u0);
RWByteAddressBuffer EmissiveVolume : register (u1);

float3 to_vlocal(float3 worldPos)
{
	// Let's get mad!
	// (x - a)/b		   : add + div
	// (x - a)*c , c = 1/b : add + mul
	// x*c + d, d = -a/b   : mad
	return worldPos*AHRVoxelizationCB.InvSceneBounds + AHRVoxelizationCB.WorldToVoxelOffset;
}

void Main(FAHRVoxelizationGSOut input)
{
	// Only voxelize if we are inside the bounds
	float3 local = to_vlocal(input.wPos);
	if( local.x > 1 || local.x < -1 ||
		local.y > 1 || local.y < -1 ||
		local.z > 1 || local.z < -1)
	{
		discard;
	}
	else
	{
		uint3 vpos = floor((local*0.5 + 0.5)*AHRVoxelizationCB.SliceSize);
		uint vidx = vpos.y + vpos.x*AHRVoxelizationCB.SliceSize.y + vpos.z*AHRVoxelizationCB.SliceSize.y*AHRVoxelizationCB.SliceSize.x;

		uint bidx = vidx >> 5;// shifting right n bits on a uint is the same as dividing by 2^n
		uint offset = vidx - 32u * bidx;

		SceneVolume.InterlockedOr(bidx*4, 1 << offset);

		// Store emissive
		uint ebidx = vidx >> 2;
		uint eoffset = vidx - 4u * ebidx;
		eoffset *= 8u;
		uint emask = ~(B8(11111111) << eoffset);

		FMaterialPixelParameters MaterialParameters = GetMaterialPixelParameters(input.FactoryInterpolants, input.Position);
		CalcMaterialParameters(MaterialParameters,true,input.Position
#if USE_WORLD_POSITION_EXCLUDING_SHADER_OFFSETS
		, input.Position // we are not storing the pos without the wo
#endif
	);

		uint idx = encode_R3G3B2(GetMaterialEmissive(MaterialParameters));

		// This should be implemented with a CAS
		EmissiveVolume.InterlockedAnd(ebidx*4, emask); // mask 
		EmissiveVolume.InterlockedOr(ebidx*4, idx << eoffset);
		//uint vox = EmissiveVolume.Load(ebidx*4);
		//vox = (vox & emask) | (AHRVoxelizationCB.EmissiveIndex << eoffset);
		//EmissiveVolume.Store(ebidx*4,vox);
	}
}
