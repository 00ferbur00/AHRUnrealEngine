// @RyanTorant
#include "AHRCommon.usf"
#include "AHRVoxelizationCommon.usf"

RWByteAddressBuffer SceneVolume : register (u0);
RWTexture3D<uint> EmissiveVolume : register (u1);

float3 to_vlocal(float3 worldPos)
{
	// Let's get mad!
	// (x - a)/b		   : add + div
	// (x - a)*c , c = 1/b : add + mul
	// x*c + d, d = -a/b   : mad
	return worldPos*AHRVoxelizationCB.InvSceneBounds + AHRVoxelizationCB.WorldToVoxelOffset;
}

void Main(FAHRVoxelizationGSOut input)
{
	// Only voxelize if we are inside the bounds
	float3 local = to_vlocal(input.wPos);
	if( local.x <= 1 && local.x >= -1 &&
		local.y <= 1 && local.y >= -1 &&
		local.z <= 1 && local.z >= -1)
	{
		uint3 vpos2 = floor((local*0.5 + 0.5)*AHRVoxelizationCB.SliceSize);
		uint vidx2 = vpos2.y + vpos2.x*AHRVoxelizationCB.SliceSize.x + vpos2.z*AHRVoxelizationCB.SliceSize.x*AHRVoxelizationCB.SliceSize.y;

#define ONE_OVER_32 0.03125f
		uint bidx = floor(float(vidx2) * ONE_OVER_32); 
		uint offset = vidx2 - 32 * bidx;

		SceneVolume.InterlockedOr(bidx*4, 1 << offset);

		// Store directly, no atomic
		EmissiveVolume[vpos2] = AHRVoxelizationCB.EmissiveIndex;
	}
}
