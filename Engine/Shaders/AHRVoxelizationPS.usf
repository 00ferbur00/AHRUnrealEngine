// @RyanTorant
#include "AHRCommon.usf"
#include "AHRVoxelizationCommon.usf"

RWByteAddressBuffer SceneVolume : register (u0);

float3 to_vlocal(float3 worldPos)
{
	// Let's get mad!
	// (x - a)/b		   : add + div
	// (x - a)*c , c = 1/b : add + mul
	// x*c + d, d = -a/b   : mad
	return worldPos*AHRVoxelizationCB.InvSceneBounds + AHRVoxelizationCB.WorldToVoxelOffset;
	

	// HARDCODED DEBUG!
	/*const float invSceneBounds = 1.0f/2150.0f;
	const float3 worldTovoxelOffset = -float3(-265.486847f,0.0f,0.0f)/2150.0f;

	return worldPos*invSceneBounds + worldTovoxelOffset;*/
}

void Main(FAHRVoxelizationGSOut input)
{
	// Only voxelize if we are inside the bounds
	float3 local = to_vlocal(input.wPos);
	if( local.x <= 1 && local.x >= -1 &&
		local.y <= 1 && local.y >= -1 &&
		local.z <= 1 && local.z >= -1)
	{
		uint3 vpos2 = floor((local*0.5 + 0.5)*AHRVoxelizationCB.SliceSize);
		uint vidx2 = vpos2.y + vpos2.x*AHRVoxelizationCB.SliceSize + vpos2.z*AHRVoxelizationCB.SliceSize*AHRVoxelizationCB.SliceSize;

	#define ONE_OVER_32 0.03125f
		uint bidx = floor(float(vidx2) * ONE_OVER_32); 
		uint offset = vidx2 - 32 * bidx;

		SceneVolume.InterlockedOr(bidx*4, 1 << offset);
	}
}
