// @RyanTorant
#include "AHRCommon.usf"
#include "AHRVoxelizationCommon.usf"

RWByteAddressBuffer SceneVolume : register (u0);
RWByteAddressBuffer EmissiveVolume : register (u1);

float3 to_vlocal(float3 worldPos)
{
	// Let's get mad!
	// (x - a)/b		   : add + div
	// (x - a)*c , c = 1/b : add + mul
	// x*c + d, d = -a/b   : mad
	return worldPos*AHRVoxelizationCB.InvSceneBounds + AHRVoxelizationCB.WorldToVoxelOffset;
}

void Main(FAHRVoxelizationGSOut input)
{
	// Only voxelize if we are inside the bounds
	float3 local = to_vlocal(input.wPos);
	if( local.x <= 1 && local.x >= -1 &&
		local.y <= 1 && local.y >= -1 &&
		local.z <= 1 && local.z >= -1)
	{
		uint3 vpos2 = floor((local*0.5 + 0.5)*AHRVoxelizationCB.SliceSize);
		uint vidx2 = vpos2.y + vpos2.x*AHRVoxelizationCB.SliceSize.y + vpos2.z*AHRVoxelizationCB.SliceSize.y*AHRVoxelizationCB.SliceSize.x;

//#define ONE_OVER_32 0.03125f
		uint bidx = vidx2/32u;//floor(float(vidx2) * ONE_OVER_32);
		uint offset = vidx2 - 32u * bidx;

		SceneVolume.InterlockedOr(bidx*4, 1 << offset);

		// Store emissive
		uint ebidx = vidx2/4u;
		uint eoffset = vidx2 - 4u * ebidx;
		eoffset *= 8u;
		uint emask = ~(B8(11111111) << eoffset);

		// This should be implemented with a CAS
		EmissiveVolume.InterlockedAnd(ebidx*4, emask); // mask 
		EmissiveVolume.InterlockedOr(ebidx*4, AHRVoxelizationCB.EmissiveIndex << eoffset);
		//uint vox = EmissiveVolume.Load(ebidx*4);
		//vox = (vox & emask) | (AHRVoxelizationCB.EmissiveIndex << eoffset);
		//EmissiveVolume.Store(ebidx*4,vox);
	}
}
